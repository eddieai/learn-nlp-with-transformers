
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <title>4.5-生成任务-语言模型 · HonKit</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="HonKit 5.1.4">
        
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/@honkit/honkit-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, user-scalable=yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="4.6-生成任务-机器翻译.html" />
    
    
    <link rel="prev" href="4.4-问答任务-多选问答.html" />
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        <li class="header">篇章1-前言</li>
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="../篇章1-前言/1.0-本地阅读和代码运行环境配置.html">
            
                <a href="../篇章1-前言/1.0-本地阅读和代码运行环境配置.html">
            
                    
                    1.0-本地阅读和代码运行环境配置
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="../篇章1-前言/1.1-Transformers在NLP中的兴起.html">
            
                <a href="../篇章1-前言/1.1-Transformers在NLP中的兴起.html">
            
                    
                    1.1-Transformers在NLP中的兴起
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">篇章2-Transformer相关原理</li>
        
        
    
        <li class="chapter " data-level="2.1" data-path="../篇章2-Transformer相关原理/2.0-前言.html">
            
                <a href="../篇章2-Transformer相关原理/2.0-前言.html">
            
                    
                    2.0-前言
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.2" data-path="../篇章2-Transformer相关原理/2.1-图解attention.html">
            
                <a href="../篇章2-Transformer相关原理/2.1-图解attention.html">
            
                    
                    2.1-图解attention
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.3" data-path="../篇章2-Transformer相关原理/2.2-图解transformer.html">
            
                <a href="../篇章2-Transformer相关原理/2.2-图解transformer.html">
            
                    
                    2.2-图解transformer
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.4" data-path="../篇章2-Transformer相关原理/2.2.1-Pytorch编写Transformer.html">
            
                <a href="../篇章2-Transformer相关原理/2.2.1-Pytorch编写Transformer.html">
            
                    
                    2.2.1-Pytorch编写Transformer
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.5" data-path="../篇章2-Transformer相关原理/2.2.1-Pytorch编写Transformer-选读.md">
            
                <span>
            
                    
                    2.2.2-Pytorch编写Transformer-选读
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.6" data-path="../篇章2-Transformer相关原理/2.3-图解BERT.html">
            
                <a href="../篇章2-Transformer相关原理/2.3-图解BERT.html">
            
                    
                    2.3-图解BERT
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.7" data-path="../篇章2-Transformer相关原理/2.4-图解GPT.html">
            
                <a href="../篇章2-Transformer相关原理/2.4-图解GPT.html">
            
                    
                    2.4-图解GPT
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.8" data-path="../篇章2-Transformer相关原理/2.5-篇章小测.html">
            
                <a href="../篇章2-Transformer相关原理/2.5-篇章小测.html">
            
                    
                    2.5-篇章小测
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">篇章3-编写一个Transformer模型：BERT</li>
        
        
    
        <li class="chapter " data-level="3.1" data-path="../篇章3-编写一个Transformer模型：BERT/3.1-如何实现一个BERT.html">
            
                <a href="../篇章3-编写一个Transformer模型：BERT/3.1-如何实现一个BERT.html">
            
                    
                    3.1-如何实现一个BERT
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.2" data-path="../篇章3-编写一个Transformer模型：BERT/3.2-如何应用一个BERT.html">
            
                <a href="../篇章3-编写一个Transformer模型：BERT/3.2-如何应用一个BERT.html">
            
                    
                    3.2-如何应用一个BERT
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.3" data-path="../篇章3-编写一个Transformer模型：BERT/3.3-篇章小测.html">
            
                <a href="../篇章3-编写一个Transformer模型：BERT/3.3-篇章小测.html">
            
                    
                    3.3-篇章小测
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">篇章4-使用Transformers解决NLP任务</li>
        
        
    
        <li class="chapter " data-level="4.1" data-path="4.0-前言.html">
            
                <a href="4.0-前言.html">
            
                    
                    4.0-前言
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.2" data-path="4.0-基于HuggingFace-Transformers的预训练模型微调.html">
            
                <a href="4.0-基于HuggingFace-Transformers的预训练模型微调.html">
            
                    
                    4.0-基于HuggingFace-Transformers的预训练模型微调
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.3" data-path="4.1-文本分类.html">
            
                <a href="4.1-文本分类.html">
            
                    
                    4.1-文本分类
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.4" data-path="4.2-序列标注.html">
            
                <a href="4.2-序列标注.html">
            
                    
                    4.2-序列标注
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.5" data-path="4.3-问答任务-抽取式问答.html">
            
                <a href="4.3-问答任务-抽取式问答.html">
            
                    
                    4.3-问答任务-抽取式问答
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.6" data-path="4.4-问答任务-多选问答.html">
            
                <a href="4.4-问答任务-多选问答.html">
            
                    
                    4.4-问答任务-多选问答
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="4.7" data-path="4.5-生成任务-语言模型.html">
            
                <a href="4.5-生成任务-语言模型.html">
            
                    
                    4.5-生成任务-语言模型
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.8" data-path="4.6-生成任务-机器翻译.html">
            
                <a href="4.6-生成任务-机器翻译.html">
            
                    
                    4.6-生成任务-机器翻译
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.9" data-path="4.7-生成任务-摘要生成.html">
            
                <a href="4.7-生成任务-摘要生成.html">
            
                    
                    4.7-生成任务-摘要生成
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.10" data-path="4.8-篇章小测.html">
            
                <a href="4.8-篇章小测.html">
            
                    
                    4.8-篇章小测
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://github.com/honkit/honkit" target="blank" class="gitbook-link">
            Published with HonKit
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >4.5-生成任务-语言模型</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <p>本文涉及的jupter notebook在<a href="https://github.com/datawhalechina/learn-nlp-with-transformers/tree/main/docs/%E7%AF%87%E7%AB%A04-%E4%BD%BF%E7%94%A8Transformers%E8%A7%A3%E5%86%B3NLP%E4%BB%BB%E5%8A%A1" target="_blank">篇章4代码库中</a>。</p>
<p>建议直接使用google colab notebook打开本教程，可以快速下载相关数据集和模型。
如果您正在google的colab中打开这个notebook，您可能需要安装Transformers和🤗Datasets库。将以下命令取消注释即可安装。</p>
<pre><code class="lang-python"><span class="hljs-comment"># ! pip install datasets transformers </span>
<span class="hljs-comment"># -i https://pypi.tuna.tsinghua.edu.cn/simple</span>
</code></pre>
<p>如果您是在本地机器上打开这个jupyter笔记本，请确保您的环境安装了上述库的最新版本。</p>
<p>您可以在<a href="https://github.com/huggingface/transformers/tree/master/examples/language-modeling" target="_blank">这里</a>找到这个jupyter笔记本的具体的python脚本文件，还可以通过分布式的方式使用多个gpu或tpu来微调您的模型。</p>
<h1 id="微调语言模型">微调语言模型</h1>
<p>在当前jupyter笔记本中，我们将说明如何使用语言模型任务微调任意<a href="https://github.com/huggingface/transformers" target="_blank">🤗Transformers</a> 模型。 </p>
<p>本教程将涵盖两种类型的语言建模任务:</p>
<ul>
<li>因果语言模型（Causal language modeling，CLM）：模型需要预测句子中的下一位置处的字符（类似BERT类模型的decoder和GPT，从左往右输入字符）。为了确保模型不作弊，模型会使用一个注意掩码防止模型看到之后的字符。例如，当模型试图预测句子中的i+1位置处的字符时，这个掩码将阻止它访问i位置之后的字符。</li>
</ul>
<p><img src="images/causal_language_modeling.png" alt="推理表示因果语言建模任务图片"></img></p>
<ul>
<li>掩蔽语言建模（Masked language modeling，MLM）：模型需要恢复输入中被"MASK"掉的一些字符（BERT类模型的预训练任务）。这种方式模型可以看到整个句子，因此模型可以根据“[MASK]”标记之前和之后的字符来预测该位置被“[MASK]”之前的字符。</li>
</ul>
<p><img src="images/masked_language_modeling.png" alt="Widget inference representing the masked language modeling task"></img></p>
<p>接下来，我们将说明如何轻松地为每个任务加载和预处理数据集，以及如何使用“Trainer”API对模型进行微调。</p>
<p>当然您也可以直接在分布式环境或TPU上运行该jupyter笔记本的python脚本版本，可以在<a href="https://github.com/huggingface/transformers/tree/master/examples" target="_blank">examples文件夹</a>中找到。</p>
<h2 id="准备数据">准备数据</h2>
<p>在接下来的这些任务中，我们将使用<a href="https://huggingface.co/datasets/wikitext#data-instances" target="_blank">Wikitext 2</a>数据集作为示例。您可以通过🤗Datasets库加载该数据集：</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> datasets <span class="hljs-keyword">import</span> load_dataset
datasets = load_dataset(<span class="hljs-string">'wikitext'</span>, <span class="hljs-string">'wikitext-2-raw-v1'</span>)
</code></pre>
<pre><code>Reusing dataset wikitext (/Users/niepig/.cache/huggingface/datasets/wikitext/wikitext-2-raw-v1/1.0.0/aa5e094000ec7afeb74c3be92c88313cd6f132d564c7effd961c10fd47c76f20)
</code></pre><p>如果碰到以下错误：
<img src="images/request_error.png" alt="request Error"></img></p>
<p>解决方案:</p>
<p>MAC用户: 在 <code>/etc/hosts</code> 文件中添加一行 <code>199.232.68.133  raw.githubusercontent.com</code></p>
<p>Windowso用户: 在 <code>C:\Windows\System32\drivers\etc\hosts</code>  文件中添加一行 <code>199.232.68.133  raw.githubusercontent.com</code></p>
<p>当然您也可以用公开在<a href="https://huggingface.co/datasets" target="_blank">hub</a>上的任何数据集替换上面的数据集，或者使用您自己的文件。只需取消注释以下单元格，并将路径替换为将导致您的文件路径：</p>
<pre><code class="lang-python"><span class="hljs-comment"># datasets = load_dataset("text", data_files={"train": path_to_train.txt, "validation": path_to_validation.txt}</span>
</code></pre>
<p>您还可以从csv或JSON文件加载数据集，更多信息请参阅<a href="https://huggingface.co/docs/datasets/loading_datasets.html#from-local-files" target="_blank">完整文档</a>。</p>
<p>要访问一个数据中实际的元素，您需要先选择一个key，然后给出一个索引:</p>
<pre><code class="lang-python">datasets[<span class="hljs-string">"train"</span>][<span class="hljs-number">10</span>]
</code></pre>
<pre><code>{'text': ' The game \'s battle system , the BliTZ system , is carried over directly from Valkyira Chronicles . During missions , players select each unit using a top @-@ down perspective of the battlefield map : once a character is selected , the player moves the character around the battlefield in third @-@ person . A character can only act once per @-@ turn , but characters can be granted multiple turns at the expense of other characters \' turns . Each character has a field and distance of movement limited by their Action Gauge . Up to nine characters can be assigned to a single mission . During gameplay , characters will call out if something happens to them , such as their health points ( HP ) getting low or being knocked out by enemy attacks . Each character has specific " Potentials " , skills unique to each character . They are divided into " Personal Potential " , which are innate skills that remain unaltered unless otherwise dictated by the story and can either help or impede a character , and " Battle Potentials " , which are grown throughout the game and always grant boons to a character . To learn Battle Potentials , each character has a unique " Masters Table " , a grid @-@ based skill table that can be used to acquire and link different skills . Characters also have Special Abilities that grant them temporary boosts on the battlefield : Kurt can activate " Direct Command " and move around the battlefield without depleting his Action Point gauge , the character Reila can shift into her " Valkyria Form " and become invincible , while Imca can target multiple enemy units with her heavy weapon . \n'}
</code></pre><p>为了快速了解数据的结构，下面的函数将显示数据集中随机选取的一些示例。</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> datasets <span class="hljs-keyword">import</span> ClassLabel
<span class="hljs-keyword">import</span> random
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-keyword">from</span> IPython.display <span class="hljs-keyword">import</span> display, HTML

<span class="hljs-keyword">def</span> <span class="hljs-title function_">show_random_elements</span>(<span class="hljs-params">dataset, num_examples=<span class="hljs-number">10</span></span>):
    <span class="hljs-keyword">assert</span> num_examples &lt;= <span class="hljs-built_in">len</span>(dataset), <span class="hljs-string">"Can't pick more elements than there are in the dataset."</span>
    picks = []
    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_examples):
        pick = random.randint(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(dataset)-<span class="hljs-number">1</span>)
        <span class="hljs-keyword">while</span> pick <span class="hljs-keyword">in</span> picks:
            pick = random.randint(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(dataset)-<span class="hljs-number">1</span>)
        picks.append(pick)

    df = pd.DataFrame(dataset[picks])
    <span class="hljs-keyword">for</span> column, typ <span class="hljs-keyword">in</span> dataset.features.items():
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(typ, ClassLabel):
            df[column] = df[column].transform(<span class="hljs-keyword">lambda</span> i: typ.names[i])
    display(HTML(df.to_html()))
</code></pre>
<pre><code class="lang-python">show_random_elements(datasets[<span class="hljs-string">"train"</span>])
</code></pre>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>text</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>On 3 March 1967 , parliament decided to build four short take @-@ off and landing airports along the Helgeland coast between Trondheim and Bodø . Braathens placed an order for a de Havilland Canada DHC @-@ 6 Twin Otter and planned to start the company Braathens STOL . It applied to operate the route without subsidies , but the concession was rejected and granted with subsidies to Widerøe , which had been operating the routes using seaplanes . \n</td>
    </tr>
    <tr>
      <th>1</th>
      <td></td>
    </tr>
    <tr>
      <th>2</th>
      <td>Rao Ramesh was cast as a tantrik who helps Gill 's character in the present era . Mumaith Khan was selected for another item number , a remix version of the hit song " Bangaru Kodipetta " from Gharana Mogudu ( 1992 ) ; Gharana Mogudu 's music was also composed by M. M. Keeravani . Chiranjeevi made a special appearance after the song , making Magadheera the first film he appeared in after his entry into politics . When Rajamouli suggested the idea of a cameo appearance , Chiranjeevi was initially hesitant till the director narrated the complete sequence and the importance of the song . \n</td>
    </tr>
    <tr>
      <th>3</th>
      <td></td>
    </tr>
    <tr>
      <th>4</th>
      <td></td>
    </tr>
    <tr>
      <th>5</th>
      <td>= = = Total Nonstop Action Wrestling ( 2015 – present ) = = = \n</td>
    </tr>
    <tr>
      <th>6</th>
      <td>The Daily Telegraph gave the visual novel the award for " Best Script " in its video game awards of 2011 , stating that " Love 's layered narrative of a high school teacher embroiled in his student ’ s worries goes places most mainstream video games wouldn 't dare . " \n</td>
    </tr>
    <tr>
      <th>7</th>
      <td></td>
    </tr>
    <tr>
      <th>8</th>
      <td></td>
    </tr>
    <tr>
      <th>9</th>
      <td></td>
    </tr>
  </tbody>
</table>


<p>正如我们所看到的，一些文本是维基百科文章的完整段落，而其他的只是标题或空行。</p>
<h2 id="因果语言模型（causal-language-modeling，clm）">因果语言模型（Causal Language Modeling，CLM）</h2>
<p>对于因果语言模型(CLM)，我们首先获取到数据集中的所有文本，并在它们被分词后将它们连接起来。然后，我们将在特定序列长度的例子中拆分它们。通过这种方式，模型将接收如下的连续文本块:</p>
<pre><code>文本1
</code></pre><p>或</p>
<pre><code>文本1结尾 [BOS_TOKEN] 文本2开头
</code></pre><p>取决于它们是否跨越数据集中的几个原始文本。标签将与输入相同，但向左移动。</p>
<p>在本例中，我们将使用<a href="https://huggingface.co/distilgpt2" target="_blank"><code>distilgpt2</code></a> 模型。您同样也可以选择<a href="https://huggingface.co/models?filter=causal-lm" target="_blank">这里</a>列出的任何一个checkpoint:</p>
<pre><code class="lang-python">model_checkpoint = <span class="hljs-string">"distilgpt2"</span>
</code></pre>
<p>为了用训练模型时使用的词汇对所有文本进行标记，我们必须下载一个预先训练过的分词器（Tokenizer）。而这些操作都可以由AutoTokenizer类完成:</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer

tokenizer = AutoTokenizer.from_pretrained(model_checkpoint, use_fast=<span class="hljs-literal">True</span>)
</code></pre>
<p>我们现在可以对所有的文本调用分词器，该操作可以简单地使用来自Datasets库的map方法实现。首先，我们定义一个在文本上调用标记器的函数:</p>
<pre><code class="lang-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">tokenize_function</span>(<span class="hljs-params">examples</span>):
    <span class="hljs-keyword">return</span> tokenizer(examples[<span class="hljs-string">"text"</span>])
</code></pre>
<p>然后我们将它应用到datasets对象中的分词，使用<code>batch=True</code>和<code>4</code>个进程来加速预处理。而之后我们并不需要<code>text</code>列，所以将其舍弃。</p>
<pre><code class="lang-python">tokenized_datasets = datasets.<span class="hljs-built_in">map</span>(tokenize_function, batched=<span class="hljs-literal">True</span>, num_proc=<span class="hljs-number">4</span>, remove_columns=[<span class="hljs-string">"text"</span>])
</code></pre>
<p>如果我们现在查看数据集的一个元素，我们会看到文本已经被模型所需的input_ids所取代:</p>
<pre><code class="lang-python">tokenized_datasets[<span class="hljs-string">"train"</span>][<span class="hljs-number">1</span>]
</code></pre>
<pre><code>{'attention_mask': [1, 1, 1, 1, 1, 1, 1, 1, 1],
 'input_ids': [796, 569, 18354, 7496, 17740, 6711, 796, 220, 198]}
</code></pre><p>下一步就有点小困难了：我们需要将所有文本连接在一起，然后将结果分割成特定<code>block_size</code>的小块。为此，我们将再次使用<code>map</code>方法，并使用选项<code>batch=True</code>。这个选项允许我们通过返回不同数量的样本来改变数据集中的样本数量。通过这种方式，我们可以从一批示例中创建新的示例。</p>
<p>首先，我们需要获取预训练模型时所使用的最大长度。最大长度在这里设置为128，以防您的显存爆炸💥。</p>
<pre><code class="lang-python"><span class="hljs-comment"># block_size = tokenizer.model_max_length</span>
block_size = <span class="hljs-number">128</span>
</code></pre>
<p>然后我们编写预处理函数来对我们的文本进行分组:</p>
<pre><code class="lang-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">group_texts</span>(<span class="hljs-params">examples</span>):
    <span class="hljs-comment"># 拼接所有文本</span>
    concatenated_examples = {k: <span class="hljs-built_in">sum</span>(examples[k], []) <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> examples.keys()}
    total_length = <span class="hljs-built_in">len</span>(concatenated_examples[<span class="hljs-built_in">list</span>(examples.keys())[<span class="hljs-number">0</span>]])
    <span class="hljs-comment"># 我们将余数对应的部分去掉。但如果模型支持的话，可以添加padding，您可以根据需要定制此部件。</span>
    total_length = (total_length // block_size) * block_size
    <span class="hljs-comment"># 通过max_len进行分割。</span>
    result = {
        k: [t[i : i + block_size] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, total_length, block_size)]
        <span class="hljs-keyword">for</span> k, t <span class="hljs-keyword">in</span> concatenated_examples.items()
    }
    result[<span class="hljs-string">"labels"</span>] = result[<span class="hljs-string">"input_ids"</span>].copy()
    <span class="hljs-keyword">return</span> result
</code></pre>
<p>首先注意，我们复制了标签的输入。</p>
<p>这是因为🤗transformer库的模型默认向右移动，所以我们不需要手动操作。</p>
<p>还要注意，在默认情况下，<code>map</code>方法将发送一批1,000个示例，由预处理函数处理。因此，在这里，我们将删除剩余部分，使连接的标记化文本每1000个示例为<code>block_size</code>的倍数。您可以通过传递更高的批处理大小来调整此行为(当然这也会被处理得更慢)。你也可以使用<code>multiprocessing</code>来加速预处理:</p>
<pre><code class="lang-python">lm_datasets = tokenized_datasets.<span class="hljs-built_in">map</span>(
    group_texts,
    batched=<span class="hljs-literal">True</span>,
    batch_size=<span class="hljs-number">1000</span>,
    num_proc=<span class="hljs-number">4</span>,
)
</code></pre>
<p>现在我们可以检查数据集是否发生了变化：现在样本包含了<code>block_size</code>连续字符块，可能跨越了几个原始文本。</p>
<pre><code class="lang-python">tokenizer.decode(lm_datasets[<span class="hljs-string">"train"</span>][<span class="hljs-number">1</span>][<span class="hljs-string">"input_ids"</span>])
</code></pre>
<pre><code>' game and follows the " Nameless ", a penal military unit serving the nation of Gallia during the Second Europan War who perform secret black operations and are pitted against the Imperial unit " Calamaty Raven ". \n The game began development in 2010, carrying over a large portion of the work done on Valkyria Chronicles II. While it retained the standard features of the series, it also underwent multiple adjustments, such as making the game more forgiving for series newcomers. Character designer Raita Honjou and composer Hitoshi Sakimoto both returned from previous entries, along with Valkyria Chronicles II director Takeshi Oz'
</code></pre><p>既然数据已经清理完毕，我们就可以实例化我们的训练器了。我们将建立一个模型:</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoModelForCausalLM
model = AutoModelForCausalLM.from_pretrained(model_checkpoint)
</code></pre>
<p>检查torch版本</p>
<pre><code class="lang-python">
<span class="hljs-keyword">import</span> importlib.util
<span class="hljs-comment"># import importlib_metadata</span>
a = importlib.util.find_spec(<span class="hljs-string">"torch"</span>) <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>
<span class="hljs-built_in">print</span>(a)
<span class="hljs-comment"># _torch_version = importlib_metadata.version("torch")</span>
<span class="hljs-comment"># print(_torch_version)</span>
</code></pre>
<pre><code>True
</code></pre><p>和一些<code>TrainingArguments</code>:</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> Trainer, TrainingArguments
</code></pre>
<pre><code class="lang-python">training_args = TrainingArguments(
    <span class="hljs-string">"test-clm"</span>,
    evaluation_strategy = <span class="hljs-string">"epoch"</span>,
    learning_rate=<span class="hljs-number">2e-5</span>,
    weight_decay=<span class="hljs-number">0.01</span>,
)
</code></pre>
<p>我们把这些都传递给<code>Trainer</code>类:</p>
<pre><code class="lang-python">trainer = Trainer(
    model=model,
    args=training_args,
    train_dataset=lm_datasets[<span class="hljs-string">"train"</span>],
    eval_dataset=lm_datasets[<span class="hljs-string">"validation"</span>],
)
</code></pre>
<p>然后就可以训练我们的模型🌶:</p>
<pre><code class="lang-python">trainer.train()
</code></pre>
<pre><code>  0%|          | 31/7002 [04:16&lt;14:27:52,  7.47s/it]
</code></pre><p>一旦训练完成，我们就可以评估我们的模型，得到它在验证集上的perplexity，如下所示:</p>
<pre><code class="lang-python"><span class="hljs-keyword">import</span> math
eval_results = trainer.evaluate()
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"Perplexity: <span class="hljs-subst">{math.exp(eval_results[<span class="hljs-string">'eval_loss'</span>]):<span class="hljs-number">.2</span>f}</span>"</span>)
</code></pre>
<h2 id="掩蔽语言模型（mask-language-modeling，mlm）">掩蔽语言模型（Mask Language Modeling，MLM）</h2>
<p>掩蔽语言模型(MLM)我们将使用相同的数据集预处理和以前一样用一个额外的步骤：</p>
<p>我们将随机"MASK"一些字符(使用"[MASK]"进行替换)以及调整标签为只包含在"[MASK]"位置处的标签(因为我们不需要预测没有被"MASK"的字符)。</p>
<p>在本例中，我们将使用<a href="https://huggingface.co/distilroberta-base" target="_blank"><code>distilroberta-base</code></a>模型。您同样也可以选择<a href="https://huggingface.co/models?filter=causal-lm" target="_blank">这里</a>列出的任何一个checkpoint:</p>
<pre><code class="lang-python">model_checkpoint = <span class="hljs-string">"distilroberta-base"</span>
</code></pre>
<p>我们可以像之前一样应用相同的分词器函数，我们只需要更新我们的分词器来使用刚刚选择的checkpoint:</p>
<pre><code class="lang-python">tokenizer = AutoTokenizer.from_pretrained(model_checkpoint, use_fast=<span class="hljs-literal">True</span>)
tokenized_datasets = datasets.<span class="hljs-built_in">map</span>(tokenize_function, batched=<span class="hljs-literal">True</span>, num_proc=<span class="hljs-number">4</span>, remove_columns=[<span class="hljs-string">"text"</span>])
</code></pre>
<p>像之前一样，我们把文本分组在一起，并把它们分成长度为<code>block_size</code>的样本。如果您的数据集由单独的句子组成，则可以跳过这一步。</p>
<pre><code class="lang-python">lm_datasets = tokenized_datasets.<span class="hljs-built_in">map</span>(
    group_texts,
    batched=<span class="hljs-literal">True</span>,
    batch_size=<span class="hljs-number">1000</span>,
    num_proc=<span class="hljs-number">4</span>,
)
</code></pre>
<p>剩下的和我们之前的做法非常相似，只有两个例外。首先我们使用一个适合掩蔽语言模型的模型:</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoModelForMaskedLM
model = AutoModelForMaskedLM.from_pretrained(model_checkpoint)
</code></pre>
<p>其次，我们使用一个特殊的data_collator。data_collator是一个函数，负责获取样本并将它们批处理成张量。</p>
<p>在前面的例子中，我们没有什么特殊的事情要做，所以我们只使用这个参数的默认值。这里我们要做随机"MASK"。</p>
<p>我们可以将其作为预处理步骤(<code>tokenizer</code>)进行处理，但在每个阶段，字符总是以相同的方式被掩盖。通过在data_collator中执行这一步，我们可以确保每次检查数据时都以新的方式完成随机掩蔽。</p>
<p>为了实现掩蔽，<code>Transformers</code>为掩蔽语言模型提供了一个<code>DataCollatorForLanguageModeling</code>。我们可以调整掩蔽的概率:</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> DataCollatorForLanguageModeling
data_collator = DataCollatorForLanguageModeling(tokenizer=tokenizer, mlm_probability=<span class="hljs-number">0.15</span>)
</code></pre>
<p>然后我们要把所有的东西交给trainer，然后开始训练:</p>
<pre><code class="lang-python">trainer = Trainer(
    model=model,
    args=training_args,
    train_dataset=lm_datasets[<span class="hljs-string">"train"</span>],
    eval_dataset=lm_datasets[<span class="hljs-string">"validation"</span>],
    data_collator=data_collator,
)
</code></pre>
<pre><code class="lang-python">trainer.train()
</code></pre>
<p>像以前一样，我们可以在验证集上评估我们的模型。</p>
<p>与CLM目标相比，困惑度要低得多，因为对于MLM目标，我们只需要对隐藏的令牌(在这里占总数的15%)进行预测，同时可以访问其余的令牌。</p>
<p>因此，对于模型来说，这是一项更容易的任务。</p>
<pre><code class="lang-python">eval_results = trainer.evaluate()
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"Perplexity: <span class="hljs-subst">{math.exp(eval_results[<span class="hljs-string">'eval_loss'</span>]):<span class="hljs-number">.2</span>f}</span>"</span>)
</code></pre>
<pre><code class="lang-python">不要忘记将你的模型[上传](https://huggingface.co/transformers/model_sharing.html)到[🤗 模型中心](https://huggingface.co/models)。
</code></pre>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="4.4-问答任务-多选问答.html" class="navigation navigation-prev " aria-label="Previous page: 4.4-问答任务-多选问答">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="4.6-生成任务-机器翻译.html" class="navigation navigation-next " aria-label="Next page: 4.6-生成任务-机器翻译">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"4.5-生成任务-语言模型","level":"4.7","depth":1,"next":{"title":"4.6-生成任务-机器翻译","level":"4.8","depth":1,"path":"篇章4-使用Transformers解决NLP任务/4.6-生成任务-机器翻译.md","ref":"./篇章4-使用Transformers解决NLP任务/4.6-生成任务-机器翻译.md","articles":[]},"previous":{"title":"4.4-问答任务-多选问答","level":"4.6","depth":1,"path":"篇章4-使用Transformers解决NLP任务/4.4-问答任务-多选问答.md","ref":"./篇章4-使用Transformers解决NLP任务/4.4-问答任务-多选问答.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":["livereload"],"pluginsConfig":{"livereload":{},"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"篇章4-使用Transformers解决NLP任务/4.5-生成任务-语言模型.md","mtime":"2024-08-23T15:34:37.400Z","type":"markdown"},"gitbook":{"version":"5.1.4","time":"2024-08-23T15:50:04.957Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-livereload/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

